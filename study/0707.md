전통적인 계층형 아키텍처는 아래 2가지를 별개로 구분
- 프레젠테이션 계층
    - 사용자와의 상호작용을 담당
- 영속성 레이어
    - 엔티티의 영속성을 처리

계층형 아키텍쳐에서 프레젠테이션 계층은 하위의 도메인 계층에 의존하고,

도메인 계층은 하위의 영속성 계층에 의존

육각형 아키텍처에서는 사용자 인터페이스나 데이터베이스 모두 비즈니스 로직으로부터 분리돼야 함

비즈니스 로직이 외부 요소에 의존하지 않고 프레젠테이션 계층과 데이터 소스 계층이 도메인 계층에 의존하도록 만들어야 함

## 육각형 아키텍쳐
- 내부
    - 비즈니스 관심사를 다룸
- 외부
    - 기술적인 관심사를 다룸

도메인 로직이 프로그램 상의 다른 관심사와 섞여 있다면 그와 같은 대응을 달성하기가 수월하지 않다
-> 도메인 주도 설계 전제 조건은 도메인 구현을 격리 = 내부와 외부의 분리

# 계층형 아키텍처의 문제는 무엇일까?
웹 -> 도메인 -> 영속성으로 이어지는 전통적인 웹 어플리케이션 구조
웹 계층에서 요청을 받아 도메인 혹은 비즈니스 계층에 있는 서비스로 요청을 보냄
서비스에서는 필요한 비즈니스 로직을 수행, 도메인 엔티티의 현재 상태를 조회하거나 변경하기 위해 영속성 계층의 컴포넌트를 호출

그림 1.2와 같이 ORM에 의해 관리되는 엔티티들은 일반적으로 영속성 계층에 둔다.
계층은 아래 방향으로만 접근 가능하기 때문에 도메인 계층에서는 이러한 엔티티에 접근할 수 있다.

그리고 이러한 엔티티에 접근할 수 있다면 분명 사용되기 마련이다.

이렇게 되면 영속성 계층과 도메인 계층 사이에 강한 결합이 생긴다.

서비스는 영속성 모델을 비즈니스 모델처럼 사용하게 되고,
이로 인해 도메인 로직 뿐 아니라, 즉시 로딩, 지연로딩, 데이터베이스 트랜잭션, 캐시 플러시 등 영속성 계층과 관련된 작엄들을 해야 한다.

만약 샹위 계층에 위치한 컴포넌트에 접근해야 하면 간단하게

영속성 계층은 컴포넌트를 아래 계층으로 내릴수록 비대해지낟.

어떤 계층에도 속하지 않는 것처럼 보이는 헬퍼 컴포넌트나 유틸리티 컴포넌트들이 이처럼 아래 계층으로 내릴 가능성이 큰 후보다.

첫 번째 문제는 단 하나의 필드를 조작하는 것에 불과하더라도 도멩니 로직을 웹 계층에 구현하게 된다는 것이다.
### 테스트하기 어려워진다.
- 단 하나 필드 조작도 도메인 로직을 웹 계층에 구현해야 한다.
- 웹 계층 테스트에서 도메인 계층 뿐만 아니라 영속성 계층도 모킹 해야 한다. -> 단위 테스트 복잡도 올라감

### 유스케이스를 숨긴다.
- 도메인 로직(서비스)가 과도하게 넓어져서 유스케이스 서비스를 숨길 수도 있음

### 동시 작업이 어려워진다.
계층형 아키텍처는 영속성 계층(엔티티, 리포지터리) 만들고, 그 위에 도메인 계층(서비스) 만들고, 웹 계층(컨트롤러) 만들어야 함

# 의존성 역전하기

단일 책임 원칙의 실정의 : 컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.

의존성 역전 원칙 : 계층형 아키텍처에서 계층 간 의존성은 항상 다음 계층인 아래 방향을 가리킨다.
-> 그러므로 영속성 계층에 대한 도메인 계층의 의존성 때문에 영속성 계층을 변경할 때마다 잠재적으로 도메인 계층도 변경해야 한다.

코드상의 어떤 의존성이든 그 방향을 바꿀 수 있다. -> 의존성 역전 원칙

의존성의 양쪽 코드를 모두 제어할 수 있을 때만 의존성을 역전시킬 수 있다.
만약, 서드파티 라이브러리에 의존성이 있다면 해당 라이브러리를 제어할 수 없기 때문에 이 의존성은 역전시킬 수 없다.

의존성 역전이 동작하는 방식?
도메인 코드 -> 영속성 코드 = 도메인 코드가 영속성 코드에 의존하고 있다.

의존성 역전을 하기 위해서는?
도메인 계층에 영속성 계층의 엔티티와 리포지토리와 상호작용하는 서비스가 하나 있다.

도메인 계층에 인터페이스를 도입함으로써 영속성 계층이 도메인 계층에 의존하게 만들 수 있습니다.

